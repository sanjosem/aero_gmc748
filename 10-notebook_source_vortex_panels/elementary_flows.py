import numpy as np
from scipy import integrate

class Source:
    """
    Contains information related to a source/sink.
    """
    def __init__(self, strength, xc, yc):
        """
        Sets the location and strength of the singularity.
        
        Parameters
        ----------
        strength: float
            Strength of the source/sink.
        xc: float
            x-coordinate of the source/sink.
        yc: float
            y-coordinate of the source/sink.
        """
        self.strength = strength
        self.xc, self.yc = xc, yc

    def compute_fields(self, X, Y):
        """
        Computes the velocity, stream and potential fields generated by the source/sink.
        
        Parameters
        ----------
        X: 2D Numpy array of floats
            x-coordinate of the mesh points.
        Y: 2D Numpy array of floats
            y-coordinate of the mesh points.
        """
        self.u = (self.strength / (2 * np.pi) *
                  (X - self.xc) / ((X - self.xc)**2 + (Y - self.yc)**2))
        self.v = (self.strength / (2 * np.pi) *
                  (Y - self.yc) / ((X - self.xc)**2 + (Y - self.yc)**2))
        self.stream = (self.strength / (2 * np.pi) *
                    np.arctan2((Y - self.yc), (X - self.xc)))
        self.potential = (self.strength / (2 * np.pi) *
                    np.log( np.sqrt((X - self.xc)**2 + (Y - self.yc)**2)) )

class Vortex:
    """
    Contains information related to a vortex
    """
    def __init__(self, strength, xc, yc):
        """
        Sets the location and strength of the singularity.
        
        Parameters
        ----------
        strength: float
            Strength of the vortex.
        xc: float
            x-coordinate of the vortex.
        yc: float
            y-coordinate of the vortex.
        """
        self.strength = strength
        self.xc, self.yc = xc, yc

    def compute_fields(self, X, Y):
        """
        Computes the velocity, stream and potential fields generated by the vortex.
        
        Parameters
        ----------
        X: 2D Numpy array of floats
            x-coordinate of the mesh points.
        Y: 2D Numpy array of floats
            y-coordinate of the mesh points.
        """
        self.u = (self.strength / (2 * np.pi) * 
            (Y - self.yc) / ((X - self.xc)**2 + (Y - self.yc)**2))
        self.v = - (self.strength / (2 * np.pi) * 
            (X - self.xc) / ((X - self.xc)**2 + (Y - self.yc)**2))
        self.stream = (self.strength / (2 * np.pi) *
                    np.log( np.sqrt((X - self.xc)**2 + (Y - self.yc)**2)) )
        self.potential = - (self.strength / (2 * np.pi) *
                    np.arctan2((Y - self.yc), (X - self.xc)))


class Uniform:
    """
    Contains information related to a uniform flow
    """
    def __init__(self, Vinf, aoa=0.):
        """
        Sets the velocity at infinity and the angle of attack.
        
        Parameters
        ----------
        Vinf: float
            Velocity magnitude of the uniform flow
        aoa : float
            Angle of attack of the flow in degree (default 0.)
        """
        self.Vinf = Vinf
        self.aoa = np.deg2rad(aoa)
    
    def compute_fields(self, X, Y):
        """
        Computes the velocity, stream and potential fields field generated by the uniform flow
        
        Parameters
        ----------
        X: 2D Numpy array of floats
            x-coordinate of the mesh points.
        Y: 2D Numpy array of floats
            y-coordinate of the mesh points.
        """
        self.u = self.Vinf * np.cos(self.aoa) * np.ones_like(X)
        self.v = self.Vinf * np.sin(self.aoa) * np.ones_like(X)
        self.stream = - self.Vinf * np.sin(self.aoa) * X + self.Vinf * np.cos(self.aoa) * Y
        self.potential = self.Vinf * np.cos(self.aoa) * X + self.Vinf * np.sin(self.aoa) * Y


class Distributed_constant_Source:
    """
    Contains information related to a distributed constant source/sink.
    """
    def __init__(self, x1, y1, x2, y2, strength):
        from math import sqrt
        """
        Sets the location and strength of the distributed source.
        
        Parameters
        ----------
        strength: float
            Constant distributed strength of the source/sink.
        x1,y1: float
            coordinates of the first point
        x2,y2: float
            coordinates of the second point
        """
        self.strength = strength
        self.x1, self.y1 = x1, y1
        self.x2, self.y2 = x2, y2
        # length of the source
        self.length = sqrt((x2-x1)**2+(y2-y1)**2)
        # print('length=',self.length)
        # The shape is described in the clockwise direction from trailing edge to trailing edge
        # x1>x2 : bottom panel, normal is pointing towards negative y and tangent towards negative x
        # x2>x2 : top panel, normal is pointing towards positive y and tangent towards positive x

        # Angle between the source and the (Ox) axis
        # acos mapping between 0 and pi
        if y1>= y2:
            self.alpha = np.pi + np.arccos( -(x2 - x1) / self.length )
        else:
            self.alpha = np.arccos( (x2 - x1) / self.length )
        # Angle between the source normal and the (Ox) axis
        # acos mapping between 0 and pi
        if x1>= x2:
            self.beta = np.pi + np.arccos( (y2 - y1) / self.length )
        else:
            self.beta = np.arccos( (y1 - y2) / self.length )

        # print('alpha=',np.rad2deg(self.alpha))
        # print('beta=',np.rad2deg(self.beta))


    def compute_velocity_analytic(self, X, Y):
        """
        Computes the velocity, stream and potential fields generated by the distributed constant source/sink.
        Using the analytic expressions
        
        Parameters
        ----------
        X: 2D Numpy array of floats
            x-coordinate of the mesh points.
        Y: 2D Numpy array of floats
            y-coordinate of the mesh points.
        """

        # global to panel coordinates : rotation by alpha
        Xp = np.cos(self.alpha) * (X-self.x1) + np.sin(self.alpha) * (Y-self.y1) 
        Yp = - np.sin(self.alpha) * (X-self.x1) + np.cos(self.alpha) * (Y-self.y1) 
        local_x1 = 0.
        local_x2 = self.length
        local_y1 = 0.
        local_y2 = 0.

        R1 = np.sqrt( (Xp**2 + Yp**2 ) )
        R2 = np.sqrt( ( (Xp-local_x2)**2 + Yp**2 ) )
        Theta1 = np.arctan2( Yp, Xp )
        Theta2 = np.arctan2( Yp, Xp-local_x2 )

        Up =  self.strength / ( 2. * np.pi ) * np.log(R1/R2)
        Vp =  self.strength / ( 2. * np.pi ) * (Theta2 - Theta1)

        # panel velocity to global velocity : rotation by alpha
        self.u =  np.cos(self.alpha) * Up - np.sin(self.alpha) * Vp
        self.v = np.sin(self.alpha) * Up + np.cos(self.alpha) * Vp   



class Distributed_constant_Vortex:
    """
    Contains information related to a distributed constant vortex.
    """
    def __init__(self, x1, y1, x2, y2, strength):
        from math import sqrt
        """
        Sets the location and strength of the distributed vortex.
        
        Parameters
        ----------
        strength: float
            Constant distributed strength of the vortex.
        x1,y1: float
            coordinates of the first point
        x2,y2: float
            coordinates of the second point
        """
        self.strength = strength
        self.x1, self.y1 = x1, y1
        self.x2, self.y2 = x2, y2
        # length of the vortex
        self.length = sqrt((x2-x1)**2+(y2-y1)**2)
        # print('length=',self.length)
        # The shape is described in the clockwise direction from trailing edge to trailing edge
        # x1>x2 : bottom panel, normal is pointing towards negative y and tangent towards negative x
        # x2>x2 : top panel, normal is pointing towards positive y and tangent towards positive x

        # Angle between the vortex and the (Ox) axis
        # acos mapping between 0 and pi
        if y1>= y2:
            self.alpha = np.pi + np.arccos( -(x2 - x1) / self.length )
        else:
            self.alpha = np.arccos( (x2 - x1) / self.length )
        # Angle between the vortex normal and the (Ox) axis
        # acos mapping between 0 and pi
        if x1>= x2:
            self.beta = np.pi + np.arccos( (y2 - y1) / self.length )
        else:
            self.beta = np.arccos( (y1 - y2) / self.length )

        # print('alpha=',np.rad2deg(self.alpha))
        # print('beta=',np.rad2deg(self.beta))


    def compute_velocity_analytic(self, X, Y):
        """
        Computes the velocity, stream and potential fields generated by the distributed constant vortex.
        Using the analytic expressions
        
        Parameters
        ----------
        X: 2D Numpy array of floats
            x-coordinate of the mesh points.
        Y: 2D Numpy array of floats
            y-coordinate of the mesh points.
        """

        # global to panel coordinates : rotation by alpha
        Xp = np.cos(self.alpha) * (X-self.x1) + np.sin(self.alpha) * (Y-self.y1) 
        Yp = - np.sin(self.alpha) * (X-self.x1) + np.cos(self.alpha) * (Y-self.y1) 
        local_x1 = 0.
        local_x2 = self.length
        local_y1 = 0.
        local_y2 = 0.

        R1 = np.sqrt( (Xp**2 + Yp**2 ) )
        R2 = np.sqrt( ( (Xp-local_x2)**2 + Yp**2 ) )
        Theta1 = np.arctan2( Yp, Xp )
        Theta2 = np.arctan2( Yp, Xp-local_x2 )

        Up =  self.strength / ( 2. * np.pi ) * (Theta2 - Theta1)
        Vp =  - self.strength / ( 2. * np.pi ) * np.log(R1/R2)

        # panel velocity to global velocity : rotation by alpha
        self.u =  np.cos(self.alpha) * Up - np.sin(self.alpha) * Vp
        self.v = np.sin(self.alpha) * Up + np.cos(self.alpha) * Vp   



